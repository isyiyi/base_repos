# 04_11 学习日志

1. json和golang结构体之间的转换
2. html/template和text/template
3. 函数
4. 错误处理


---

**json编码**

在使用json.Marshall()进行结构体转json的过程中，如果结构体成员变量首字母小写，将不会被导出和转换
；使用json.UnMarshall()进行反序列化

**可以使用Tag来控制json转换后的名字**
```go
type Name struct {
	// 转换后就是小写的id
	Id int `json:"id"`
	
	// 如果结构体变量的值为空或零值就不生成对应的对象
	School string `json:"school, omitempty"`
}
```

---

**template模板文件编写**

.为传入模板文件的一级，访问其中元素都要用.xxx来访问

{{range .xxx}}来遍历传入对象的xxx变量

如果xxx为数组，则{{.}}为遍历过程中每个位置的元素

--- 

**函数**

1. 函数的形参可以是普通类型和引用类型，普通类型是用户调用函数时提供的值的拷贝，引用类型在函数内部会修改指向内存空间的值
2. 函数的返回值可以有多个
   1. 多返回值的函数可以作为另一个对应数量和类型的函数的参数
   2. 如果两个函数的返回值类型和数量一致，那么可以在一个函数内将另一个函数的调用作为返回值
   3. 如果返回值的变量名已经在函数声明中给出，那么必须显式的为这些返回值变量赋值，最后return即可
3. 如果多个参数的类型相同，可以在多个变量名之后写一个类型；如果多个返回值的类型相同，可以在多个返回值变量的后面写一个类型（仅适用于显式声明返回值变量名的）
4. 可变参数使用...标注，可变参数只能位于固定参数的后边，并且可变参数在函数体内部是一个切片类型；如果参数已经是一个定义好的切片类型，可以使用 func(xxx...)的方式对参数进行拆包

---

**错误处理**

error是接口类型，要么是nil（运行成功），要么是non-nil（运行失败，error类型包含错误信息）

发生错误时，如果是非main函数，则应向上传播错误；

如果是main函数：
   1. 进行有限次和有间隔的尝试，实在不行返回错误
   2. 如果错误严重影响程序的正常运行，则可以直接中断程序
   
`log.Fatalln(err)`可以输出时间信息，但是会直接中断程序；
可以使用`log.Println(err)  or fmt.Fprintf(os.Stderr, "%s", err)`来输出错误信息
**错误打印信息会在所有的输出执行之后才输出**

**error和panic**


---


**匿名函数**

只有方法体，没有方法名，并且在函数内部定义的匿名函数可以访问该函数的其他变量

**匿名函数作为返回值时，它的成员变量值都会一直保留，不会被释放**

```go
func FuncUse() func() int {
	var x int
	return func() int {
		x += 1
		return x
	}
}

// 调用
var f func() int = content.FuncUse()
fmt.Println(f())        // 1
fmt.Println(f())        // 2，会记录上次x的值，再加一
fmt.Println(f())        // 3


// 或者先声明一个函数类型，再创建匿名变量

var x func() int 
x = func() int {
	// 方法体
}
```