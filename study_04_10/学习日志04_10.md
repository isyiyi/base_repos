# golang 04_10 学习日志

**学习内容：**

1. 复习变量相关内容
    1. 单变量声明再赋值
    2. 单变量声明并赋值
    3. 多变量声明再赋值
    4. 多变量声明并赋值
    5. 自动类型推断
    6. 短变量声明赋值（只能在函数内部使用）
2. 了解包和模块相关内容
3. 了解数据类型（基础类型、复合类型、引用类型、接口类型）
    1. 指针
    2. 常量、变量（使用new函数创建变量）**定义在包一级的变量和常量和函数，如果首字母大写，可以被外部包使用；同一个包的不同文件间，首字母大小写的变量、常量、函数可以直接调用**
    3. type为数据类型起别名
    4. 数组
    5. 切片
    6. 字典
    7. 结构体
4. 变量的生命周期（运行时概念）和作用域（文本概念）
---

## 包和模块

golang中的所有.go文件都要指定其所在的包（package），包有两种类型 main、非main，main函数只能写在main包内，是整个包的入口函数

**文件名和包名没有什么直接关系，包名可以自己指定**

**一个文件夹内的所有文件都必须指定为一个包名（一个包的源代码可以由一个或多个.go源文件构成），不能出现多个包**

**包的导入：**

1. 使用import导入包，import后跟包所在的路径（路径其实就是该包所在文件夹的绝对路径，但通常会从GOPATH/src下找）（非自己指定的包名）；意为到这个路径下寻找第二步使用的包
2. 调用时使用包名.函数名来调用
3.
因为一个文件夹下可以再创建一个文件夹，而子级文件夹下的包可以指定为和父级文件夹下的包一致（golang只要求同级文件夹下包一致，并未要求所有的包不能一致），此时，如果导入两个包，编译器将无法从多个相同名称的包内找到函数或变量，所以可以在import后为包起别名

**golang的包搜索模式**

1. 先从`GOROOT/src`下搜索包（一般都是golang内置的包）
2. 如果包不存在，就会从`GOPATH/src`下寻找用户的自定义包或第三方包
3. 使用.从当前路径下引入包

> `go 1.12`版本之前
>
安装golang编译器之后，要配置gopath、goroot、path环境变量。 其中goroot和path配置的是golang编译器的安装目录 ； gopath配置的是golang的工作目录，包括：src、bin、pkg，其中:

src：存放的是golang的源代码文件，可以创建多个项目，每个项目是一个文件夹

bin：存放的是go build之后的二进制文件

pkg：存放的是非main包的中间连接文件

> `go 1.12`版本之后
>
不再强制要求GOPATH，而是隐式的创建go文件夹，go get之后的软件包会被放到`go/pkg/mod`目录下，由此的好处是，用户不需要每次创建项目都必须在GOPATH的src目录下。

只是在每次新建项目时需要使用`go mod init 项目名`来初始化，会生成一个go.mod文件。这个文件记载着这个项目的所有import库，当库缺失时，会自动搜索本地或go get远程库。

---

**指针**

```go
var x int = 90
var p = &x
fmt.Println(*p)
*p = 98
```

上述代码中，p为指向变量x内存空间的指针，通过修改p指向内存空间的值进而修改变量x的值

计算机执行的原理：

1. `var x int = 90`，计算机在内存中开辟了一块int类型大小的空间(假设为060001)，并把该空间的值修改为90，再把地址赋给变量x
2. `var p = &x`，同样地，计算机在内存中开辟了一块int*类型大小的空间，并把x变量指向的内存空间的地址赋值给p，即p变量指向的内存空间的值为x指向的内存空间的地址060001

**在golang中，函数可以返回指针（得益于golang的垃圾回收机制，被指针引用的变量指向的内存地址在函数调用结束之后不会被回收）**

**同样地，函数的参数也可以是指针，当在函数中操作指针指向的值时，原来的变量的值也会相应的发生变化（因为二者实质上指向的是一块内存）**

使用`new(T)`将创建一个T类型的匿名变量，并将该变量初始化为T类型的初始值，**返回的是开辟的内存地址**

---

type可以为编译器提供的数据类型起别名

如：

```golang
type newInt int
var num1 newInt = 90
var num2 int = 90
// 此时两个变量虽然具备相同的底层数据结构，但是不具备任何的显式关系，不能进行运算和比较
// 可以通过显式的类型变换来使用
fmt.Println(num1 == newInt(num2))
```

---

**数据类型**

数据类型的分类：
   1. 基础类型
      1. 数字
      2. 字符串
      3. 布尔类型
   2. 复合类型
      1. 数组
      2. 结构体
   3. 引用类型
      1. 指针
      2. 切片
      3. 字典
      4. 函数
      5. 通道
   4. 接口类型
   
算术运算
位运算

golang支持直接为整型变量赋值八进制和十六进制
如：
```go
var num1 int = 0o45
var num2 int = 0xad9
```
在输出时，可以使用fmt.Printf进行格式化输出

%d输出整型（如果是字符，将输出对应的ASCII码）

%o输出八进制

%x输出十六进制

%c输出字符

%q输出字符时带单引号

%g、%f、%e(带指数e)都可以打印浮点数，并且可以控制数据宽度和小数部分的精度

%T输出变量的数据类型

%t输出布尔类型的值


通过在格式化输出中添加[1]来指定使用哪个操作数，使用#来指定输出八进制或十六进制时带前缀
```go
fmt.Printf("%d\t%#[1]o\t%#[1]x\n", num2)
```

字符串的切片操作，同Python

常量初始化时，可以批量初始化，也可以使用iota来初始化
```go
const(
	a = 1
	b       // 如果不写，默认与上一个值一致
	c = 3
	d
)

const(
    KiB = iota    // 0
    MiB = 2       // 2，如果有手动赋值，就用手动赋值，但是iota仍然按照+1的规律增加
	tmp           // 2，再没出现iota和手动赋值之前，与上方一样，都只会赋和上边一个一样的值
	tmp_1         // 2
    GiB = iota    // 4，出现iota之后，就按照iota赋值，下一个按照规律+1
    TiB           // 5
)
```

---

**数组**

声明数组的语法：
```go
// 不初始化默认为T类型的初始值
var a [len]T
// 初始化的值的个数没有达到len长度，其余的仍为初始化的值
var a [len]T = [len]T {x, x, x....}
// ...表示初始化时不知道数组有多长
a := [...]T {}
// 也可以使用iota常量来赋值，指定初始化位置（不一定必须要使用iota语法，直接写0，1，2一样）
const(
	USD = iota
	EUR
	GBP
)
var money = [...]string {USD: "$", EUR: "€", GBP: "￡"}
```

遍历数组的语法：`for k, v := range(){k是索引，v是值}`

数组的索引从0到len()-1

**golang中数组作为函数参数时是值传递，并不是引用传递，可以使用`p *T[]`的方式传入数组指针**

**切片：**

切片slice，包含三部分：指针、容量、长度，可以追加一个、多个元素或一个切片

容量：slice[start: end]，从start到底层数组的结尾部分的长度

长度：end - start，长度一定要小于容量，否则将报错，因为从start位置到底层数组的最后最大只能切 容量 那么大的数据

指针：指向切片的第一个元素，但可能不是底层数组的第一个元素

**因为slice是指向底层数组的一个指针，所以如果在函数中传入切片时，修改切片的内容将修改底层数组的值（切片的第一个位置并不一定是数组的第一个位置）**

```go
// 切片的初始化语法
// 切片并不要求写入长度，是可变长的数组，会自己扩展长度
var nums = []int {1, 2, 3, ...}

// 或者使用make函数来创建一个slice
// cap可以省略，省略时cap==len，显式声明时cap>=len
make([]T, len, cap)
```

**如果使用索引方式修改和查看元素内容，只能操作len之前的，对于len和cap之间的只能在append追加之后才能使用索引方式查看和修改**

**关于slice的底层逻辑**
```go
/* slice的append底层实现:(slice创建时的空间可以直接使用索引方式赋值，使用append的方式都是在原有长度之后进行的)
1. 比较source的长度和容量：
	1.1 如果长度小于容量，就在source的底层数组上重新切片，长度较source+1
	1.2 如果长度等于容量，就重新分配一个二倍容量的底层数组，并把source的值赋值过去
*/
func appendInt(source []int, num int) []int {
    var res []int
	// 还有容量容纳新元素
    if len(source) < cap(source) {
        res = source[:len(source)+1]
    } else {
		// 没有容量和长度，就新分配一个
        if cap(source) == 0 {
            res = make([]int, 1, 4)
        }else{
			// 没有容量供使用，就扩展新数组
            res = make([]int, len(source)+1, cap(source)*2)
            for k, v := range source {
                res[k] = v
            }
        }
    }
    res[len(source)] = num
    return res
}
```


---

**map哈希表**
```go
// 创建语法
var mapT = make(map[string]int)
// 或者初始化一些内容
var mapT = map[string]int {
	"alice": 34, 
	"paul": 4
}


// 遍历语法
for name := range mapT {
	// 如果写一个变量，只能得到mapT的key
	// 因为map的遍历是无序的，每次都不一样，如果想要有序遍历，可以先将key排序再取值
}

for name, val := range mapT {
	// 可以得到key和value
}

// 通过val, ok := mapT[key]来取值
// 如果key存在于map中，val就返回对应的值，如果不存在就返回对应类型的零值，第二个返回值也会标识是否存在
```

`var mapT map[string]int`只声明不使用make创建空间，赋值会报错

---

**结构体**

```go
// 语法
type StructName struct{
	xx type
	xxx type 
	// 如果类型相同，可以写在一行
	xx, xxxx type
	...
}

// 结构体的成员通过.来访问
// 同样可以对结构体的成员取地址，因为他仍然是一个变量
var VariableName StructName
Variable.xx = xxx
// or
var PtrVariableName *StructName = &VariableName
// 对于指向结构体的指针，可以直接使用.来操作
PtrVariableName.xx = xxx
// 等价于
(*PtrVariableName).xx = xxx

// 在声明时，可以直接初始化
// 可以按照顺序初始化或者指定成员变量名
```
**结构体内的成员变量如果以首字母大写，则这个成员变量就是导出的**

**结构体传参仍然是值传递，如果想要在函数内部修改结构体的值，要使用指针传参**

**如果结构体内部的成员变量都是可比较的，那么结构体也是可比较的**

```go
type A struct{
	X, Y int
}

// 结构体可以嵌套
type B struct{
	a A
}

var b B
b.a.X = xxxx

// 使用匿名变量，只声明变量的类型并不声明变量的名字
type C struct {
	A
}
// 使用匿名变量访问时，直接可以访问匿名变量的成员变量(变相的继承)
var c C
c.X = xxx
// c.A.X = xxx 同样有效

// 在初始化时，不能直接使用匿名变量的成员变量来初始化
// 需要遵循结构体的形状
var c C = C{A: A{X: xx, Y: xxx}}
```